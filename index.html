<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LuckyU - Wallet & Lottery Dashboard</title>
  <!-- Load scripts with integrity checks and fallbacks -->
  <script src="https://unpkg.com/react@18.2.0/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18.2.0/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone@7.24.7/babel.min.js" crossorigin></script>
  <script src="https://unpkg.com/ethers@6.13.2/dist/ethers.umd.min.js" crossorigin></script>
  <script src="https://unpkg.com/@walletconnect/ethereum-provider@2.14.0/dist/index.umd.js" crossorigin></script>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .fallback-message {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      text-align: center;
      padding: 20px;
      background: linear-gradient(to bottom, #8b5cf6, #ec4899);
      color: white;
    }
    .fallback-message h1 {
      font-size: 24px;
      margin-bottom: 10px;
    }
    .fallback-message p {
      font-size: 16px;
      margin-bottom: 20px;
    }
    .fallback-message button {
      padding: 10px 20px;
      background-color: white;
      color: #8b5cf6;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <div id="fallback" class="fallback-message" style="display: none;">
    <h1>⚠️ Something Went Wrong</h1>
    <p>Unable to load the LuckyU app. Please try refreshing the page or check the console for errors.</p>
    <button onclick="window.location.reload()">Refresh</button>
  </div>

  <script type="text/babel">
    // Check if dependencies are loaded
    if (!window.React || !window.ReactDOM || !window.Babel || !window.ethers) {
      console.error("Failed to load one or more dependencies:", {
        React: !!window.React,
        ReactDOM: !!window.ReactDOM,
        Babel: !!window.Babel,
        ethers: !!window.ethers,
        WalletConnect: !!window.WalletConnect,
        Telegram: !!window.Telegram,
      });
      document.getElementById("root").style.display = "none";
      document.getElementById("fallback").style.display = "flex";
      throw new Error("Required dependencies not loaded.");
    }

    const { ethers } = window;
    const WalletConnect = window.WalletConnect || {};
    const { EthereumProvider } = WalletConnect;

    // Placeholder contract addresses (replace with actual addresses)
    const LUCK_TOKEN_ADDRESS = "0x7c1209fb8f73e37b43f25da2dd81a00565f90607";
    const LOTTERY_CONTRACT_ADDRESS = "0x58e319bb163a6952a3cff5d08f9f08112566da90";

    // Simplified ABI for the contracts (replace with actual ABIs)
    const LUCK_TOKEN_ABI = [
      "function approve(address spender, uint256 amount) public returns (bool)",
      "function allowance(address owner, address spender) public view returns (uint256)",
      "function balanceOf(address account) public view returns (uint256)",
      "function decimals() public view returns (uint8)"
    ];
    const LOTTERY_CONTRACT_ABI = [
      "function enterLottery(uint256 numberOfTickets) public",
      "function ticketPrice() public view returns (uint256)",
      "function currentLotteryId() public view returns (uint256)",
      "function getLotteryInfo(uint256 lotteryId) public view returns (uint256 startTime, uint256 endTime, uint256 resultTime, bool ended, uint256 participantCount, uint256 prizePool)"
    ];

    function App() {
      const [telegramId, setTelegramId] = React.useState("");
      const [account, setAccount] = React.useState(null);
      const [provider, setProvider] = React.useState(null);
      const [signer, setSigner] = React.useState(null);
      const [lotteryContract, setLotteryContract] = React.useState(null);
      const [luckToken, setLuckToken] = React.useState(null);
      const [lotteryInfo, setLotteryInfo] = React.useState(null);
      const [ticketPrice, setTicketPrice] = React.useState(0);
      const [ticketAmount, setTicketAmount] = React.useState(1);
      const [status, setStatus] = React.useState("");
      const [isLoading, setIsLoading] = React.useState(false);
      const [action, setAction] = React.useState("connect"); // "connect", "buy"
      const [isMobile, setIsMobile] = React.useState(false);
      const [walletProvider, setWalletProvider] = React.useState(null); // "metamask", "walletconnect", null

      // Initialize Telegram Web App and fetch lottery info
      React.useEffect(() => {
        console.log("Initializing LuckyU app...");
        // Telegram Web App setup
        if (window.Telegram && window.Telegram.WebApp) {
          console.log("Telegram Web App detected.");
          window.Telegram.WebApp.ready();
          const user = window.Telegram.WebApp.initDataUnsafe.user;
          if (user) {
            setTelegramId(user.id.toString());
            console.log("Telegram user ID set:", user.id);
          }

          // Initialize MainButton
          window.Telegram.WebApp.MainButton.setText("Connect Wallet");
          window.Telegram.WebApp.MainButton.show();
        } else {
          console.warn("Not running in Telegram Web App environment.");
        }

        // Detect mobile device
        const userAgent = navigator.userAgent || navigator.vendor || window.opera;
        setIsMobile(/android|iPhone|iPad|iPod/i.test(userAgent));
        console.log("Is mobile device:", isMobile);

        // Check for MetaMask (only for external browser)
        if (window.ethereum && !window.Telegram.WebApp.initDataUnsafe) {
          console.log("MetaMask detected in external browser.");
          setWalletProvider("metamask");
          const provider = new ethers.BrowserProvider(window.ethereum);
          setProvider(provider);

          const luckToken = new ethers.Contract(LUCK_TOKEN_ADDRESS, LUCK_TOKEN_ABI, provider);
          const lotteryContract = new ethers.Contract(LOTTERY_CONTRACT_ADDRESS, LOTTERY_CONTRACT_ABI, provider);
          setLuckToken(luckToken);
          setLotteryContract(lotteryContract);
        } else {
          setWalletProvider(null);
          setStatus(isMobile
            ? "Please connect your wallet using MetaMask or WalletConnect."
            : "Please connect your wallet using WalletConnect, or open in a browser to use MetaMask.");
          console.log("No MetaMask detected in this environment.");
        }

        // Fetch lottery info if provider is set
        const fetchLotteryInfo = async () => {
          if (!lotteryContract) {
            console.warn("Lottery contract not initialized yet.");
            return;
          }
          try {
            console.log("Fetching lottery info...");
            const currentId = await lotteryContract.currentLotteryId();
            if (currentId > 0) {
              const [startTime, endTime, resultTime, ended, participantCount, prizePool] = await lotteryContract.getLotteryInfo(currentId);
              setLotteryInfo({
                id: currentId,
                startTime: new Date(startTime * 1000).toUTCString(),
                endTime: new Date(endTime * 1000).toUTCString(),
                resultTime: new Date(resultTime * 1000).toUTCString(),
                ended,
                participantCount,
                prizePool: ethers.formatEther(prizePool)
              });
              const ticketPrice = await lotteryContract.ticketPrice();
              setTicketPrice(ethers.formatEther(ticketPrice));
              console.log("Lottery info fetched:", {
                id: currentId,
                prizePool: ethers.formatEther(prizePool),
                ticketPrice: ethers.formatEther(ticketPrice)
              });
            } else {
              setLotteryInfo({ id: 0 });
              console.log("No active lottery found.");
            }
          } catch (error) {
            setStatus(`Error fetching lottery info: ${error.message}`);
            console.error("Error fetching lottery info:", error);
          }
        };
        fetchLotteryInfo();

        // Pre-fill ticket amount from query params (if coming from /buy_tickets)
        const params = new URLSearchParams(window.location.search);
        const tickets = params.get("tickets");
        if (tickets) {
          setTicketAmount(Math.max(1, parseInt(tickets) || 1));
          setAction("buy");
          console.log("Pre-filled ticket amount:", tickets);
        }

        // Clean up MainButton event listeners on unmount
        return () => {
          if (window.Telegram && window.Telegram.WebApp) {
            window.Telegram.WebApp.MainButton.offClick();
          }
        };
      }, [lotteryContract]);

      // Update MainButton based on state
      React.useEffect(() => {
        if (!window.Telegram || !window.Telegram.WebApp.MainButton) return;

        if (isLoading) {
          window.Telegram.WebApp.MainButton.setText("Processing...");
          window.Telegram.WebApp.MainButton.disable();
          return;
        }

        window.Telegram.WebApp.MainButton.enable();
        if (!walletProvider && !account) {
          if (isMobile) {
            window.Telegram.WebApp.MainButton.setText("Connect with MetaMask");
            window.Telegram.WebApp.MainButton.onClick(connectWalletMetaMaskMobile);
          } else {
            window.Telegram.WebApp.MainButton.setText("Connect with WalletConnect");
            window.Telegram.WebApp.MainButton.onClick(connectWalletConnect);
          }
        } else if (action === "connect" && !account) {
          window.Telegram.WebApp.MainButton.setText("Connect Wallet");
          window.Telegram.WebApp.MainButton.onClick(walletProvider === "metamask" ? connectWalletMetaMask : connectWalletConnect);
        } else if (action === "buy") {
          window.Telegram.WebApp.MainButton.setText(`Buy ${ticketAmount} Ticket${ticketAmount > 1 ? 's' : ''}`);
          window.Telegram.WebApp.MainButton.onClick(buyTickets);
        } else {
          window.Telegram.WebApp.MainButton.setText("Buy Tickets");
          window.Telegram.WebApp.MainButton.onClick(() => setAction("buy"));
        }
      }, [walletProvider, isMobile, account, action, ticketAmount, isLoading]);

      const connectWalletMetaMask = async () => {
        setIsLoading(true);
        setStatus("");
        try {
          if (!provider) {
            setStatus("MetaMask not detected. Please install MetaMask.");
            setIsLoading(false);
            return;
          }

          const accounts = await provider.send("eth_requestAccounts", []);
          const signer = await provider.getSigner();
          setAccount(accounts[0]);
          setSigner(signer);
          setStatus("Wallet connected! Verifying ownership...");
          console.log("MetaMask connected, account:", accounts[0]);

          // Generate nonce and sign message
          const nonce = Math.floor(Math.random() * 900000000) + 100000000;
          const message = `LuckyU: Link wallet to Telegram ID ${telegramId}. Nonce: ${nonce}`;
          const signature = await signer.signMessage(message);

          // Send wallet address and signature to bot
          window.Telegram.WebApp.sendData(JSON.stringify({
            type: "wallet_verification",
            address: accounts[0],
            signature,
            message
          }));
          setStatus("Wallet verification submitted! Please wait for confirmation.");
          setAction("buy"); // Switch to buy mode after connecting
        } catch (error) {
          setStatus(`Error connecting wallet: ${error.message}`);
          console.error("Error connecting MetaMask:", error);
        } finally {
          setIsLoading(false);
        }
      };

      const connectWalletMetaMaskMobile = async () => {
        setIsLoading(true);
        setStatus("");
        try {
          // Generate nonce and message for signing
          const nonce = Math.floor(Math.random() * 900000000) + 100000000;
          const message = `LuckyU: Link wallet to Telegram ID ${telegramId}. Nonce: ${nonce}`;
          
          // Create a deep link to MetaMask for signing
          const encodedMessage = encodeURIComponent(message);
          const deepLink = `https://metamask.app.link/dapp/${window.location.host}${window.location.pathname}?action=sign&message=${encodedMessage}&telegramId=${telegramId}&nonce=${nonce}\\/`;
          
          // Open MetaMask app
          window.Telegram.WebApp.openLink(deepLink);
          
          setStatus("Please sign the message in MetaMask, then return to Telegram to continue.\nAfter signing, you may need to reconnect your wallet to proceed.");
          console.log("Opened MetaMask deep link:", deepLink);
        } catch (error) {
          setStatus(`Error connecting wallet on mobile: ${error.message}`);
          console.error("Error connecting MetaMask on mobile:", error);
        } finally {
          setIsLoading(false);
        }
      };

      const connectWalletConnect = async () => {
        setIsLoading(true);
        setStatus("");
        try {
          if (!EthereumProvider) {
            setStatus("WalletConnect is not available. Please open in a browser to use MetaMask.");
            console.error("WalletConnect EthereumProvider not found.");
            return;
          }

          // Initialize WalletConnect provider
          const wcProvider = await EthereumProvider.init({
            projectId: "d2d229c72d13ca005fc97d00ecc76757", // Replace with your WalletConnect Project ID
            chains: [97], // BNB Chain mainnet (use 97 for testnet)
            showQrModal: true,
            methods: ["eth_requestAccounts", "eth_sign", "personal_sign"],
            events: ["chainChanged", "accountsChanged"],
          });

          // Connect to WalletConnect
          await wcProvider.connect();
          const provider = new ethers.BrowserProvider(wcProvider);
          setProvider(provider);
          setWalletProvider("walletconnect");

          const accounts = await provider.send("eth_requestAccounts", []);
          const signer = await provider.getSigner();
          setAccount(accounts[0]);
          setSigner(signer);
          setStatus("Wallet connected via WalletConnect! Verifying ownership...");
          console.log("WalletConnect connected, account:", accounts[0]);

          // Set up contracts
          const luckToken = new ethers.Contract(LUCK_TOKEN_ADDRESS, LUCK_TOKEN_ABI, provider);
          const lotteryContract = new ethers.Contract(LOTTERY_CONTRACT_ADDRESS, LOTTERY_CONTRACT_ABI, provider);
          setLuckToken(luckToken);
          setLotteryContract(lotteryContract);

          // Generate nonce and sign message
          const nonce = Math.floor(Math.random() * 900000000) + 100000000;
          const message = `LuckyU: Link wallet to Telegram ID ${telegramId}. Nonce: ${nonce}`;
          const signature = await signer.signMessage(message);

          // Send wallet address and signature to bot
          window.Telegram.WebApp.sendData(JSON.stringify({
            type: "wallet_verification",
            address: accounts[0],
            signature,
            message
          }));
          setStatus("Wallet verification submitted! Please wait for confirmation.");
          setAction("buy"); // Switch to buy mode after connecting
        } catch (error) {
          setStatus(`Error connecting with WalletConnect: ${error.message}`);
          console.error("Error connecting WalletConnect:", error);
        } finally {
          setIsLoading(false);
        }
      };

      const approveTokens = async (amount) => {
        setIsLoading(true);
        setStatus("");
        try {
          if (!signer || !luckToken) {
            setStatus("Please connect your wallet first.");
            setIsLoading(false);
            return;
          }

          const amountBigInt = ethers.parseEther(amount.toString());
          const tx = await luckToken.connect(signer).approve(LOTTERY_CONTRACT_ADDRESS, amountBigInt);
          await tx.wait();
          setStatus("Approval successful! Proceeding to buy tickets...");
          console.log("Token approval successful.");
        } catch (error) {
          setStatus(`Error approving tokens: ${error.message}`);
          console.error("Error approving tokens:", error);
          throw error;
        } finally {
          setIsLoading(false);
        }
      };

      const buyTickets = async () => {
        setIsLoading(true);
        setStatus("");
        try {
          if (!signer || !lotteryContract || !luckToken) {
            setStatus("Please connect your wallet first.");
            setIsLoading(false);
            return;
          }

          if (!lotteryInfo || lotteryInfo.id === 0) {
            setStatus("No active lottery available.");
            setIsLoading(false);
            return;
          }

          if (lotteryInfo.ended || new Date(lotteryInfo.endTime) < new Date()) {
            setStatus("This lottery has ended. Please wait for the next one.");
            setIsLoading(false);
            return;
          }

          const totalCost = ticketPrice * ticketAmount;
          const balance = await luckToken.balanceOf(account);
          if (ethers.formatEther(balance) < totalCost) {
            setStatus(`Insufficient $LUCK balance. You need ${totalCost} $LUCK.`);
            setIsLoading(false);
            return;
          }

          const allowance = await luckToken.allowance(account, LOTTERY_CONTRACT_ADDRESS);
          if (ethers.formatEther(allowance) < totalCost) {
            setStatus(`Insufficient allowance. Approving ${totalCost} $LUCK...`);
            await approveTokens(totalCost);
          }

          const tx = await lotteryContract.connect(signer).enterLottery(ticketAmount);
          await tx.wait();
          setStatus(`Successfully bought ${ticketAmount} ticket(s)!`);
          console.log(`Bought ${ticketAmount} ticket(s) successfully.`);

          // Send confirmation to bot
          window.Telegram.WebApp.sendData(JSON.stringify({
            type: "purchased",
            tickets: ticketAmount
          }));
        } catch (error) {
          setStatus(`Error buying tickets: ${error.message}`);
          console.error("Error buying tickets:", error);
        } finally {
          setIsLoading(false);
        }
      };

      return (
        <div className="min-h-screen bg-gradient-to-b from-purple-500 to-pink-500 flex items-center justify-center p-4">
          <div className="bg-white rounded-lg shadow-xl p-6 max-w-lg w-full">
            <div className="flex items-center justify-center mb-4">
              <h1 className="text-3xl font-bold text-purple-600">LuckyU 🦙</h1>
            </div>

            {/* Wallet Section */}
            <div className="mb-6">
              <h2 className="text-xl font-semibold text-gray-800 mb-2">Wallet</h2>
              {account ? (
                <div className="bg-green-100 p-3 rounded-lg">
                  <p className="text-green-800 font-medium">
                    Connected: {account.slice(0, 6)}...{account.slice(-4)}
                  </p>
                </div>
              ) : (
                <p className="text-gray-600">
                  {walletProvider === "metamask"
                    ? "Click the button below to connect your MetaMask wallet."
                    : isMobile
                      ? "Click the button below to connect with the MetaMask mobile app."
                      : "Click the button below to connect with WalletConnect (or open in browser for MetaMask)."}
                </p>
              )}
            </div>

            {/* Lottery Info Section */}
            <div className="mb-6">
              <h2 className="text-xl font-semibold text-gray-800 mb-2">Current Lottery</h2>
              {lotteryInfo && lotteryInfo.id > 0 ? (
                <div className="bg-gray-100 p-4 rounded-lg">
                  <p className="text-gray-700">Lottery ID: #{lotteryInfo.id}</p>
                  <p className="text-gray-700">Prize Pool: {lotteryInfo.prizePool} $LUCK</p>
                  <p className="text-gray-700">Participants: {lotteryInfo.participantCount}</p>
                  <p className="text-gray-700">Ends: {lotteryInfo.endTime}</p>
                  <p className="text-gray-700">Ticket Price: {ticketPrice} $LUCK</p>
                </div>
              ) : (
                <p className="text-gray-600">No active lottery yet. Stay tuned! 🦙</p>
              )}
            </div>

            {/* Buy Tickets Section */}
            {lotteryInfo && lotteryInfo.id > 0 && action === "buy" && (
              <div className="mb-6">
                <h2 className="text-xl font-semibold text-gray-800 mb-2">Buy Tickets 🎟️</h2>
                <div className="flex items-center space-x-4 mb-4">
                  <input
                    type="number"
                    min="1"
                    value={ticketAmount}
                    onChange={(e) => setTicketAmount(Math.max(1, parseInt(e.target.value) || 1))}
                    className="w-20 p-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500"
                  />
                  <p className="text-gray-600">
                    Total: {(ticketPrice * ticketAmount).toFixed(2)} $LUCK
                  </p>
                </div>
              </div>
            )}

            {/* Status Messages */}
            {status && (
              <div className={`p-3 rounded-lg text-sm ${
                status.includes('Error') ? 'bg-red-100 text-red-800' : 'bg-green-100 text-green-800'
              }`}>
                {status}
              </div>
            )}
          </div>
        </div>
      );
    }

    // Error boundary component to catch rendering errors
    class ErrorBoundary extends React.Component {
      state = { hasError: false };

      static getDerivedStateFromError(error) {
        return { hasError: true };
      }

      componentDidCatch(error, errorInfo) {
        console.error("Error rendering React app:", error, errorInfo);
        document.getElementById("root").style.display = "none";
        document.getElementById("fallback").style.display = "flex";
      }

      render() {
        if (this.state.hasError) {
          return null; // Fallback UI is handled by the DOM
        }
        return this.props.children;
      }
    }

    // Render the app with error boundary
    try {
      ReactDOM.render(
        <ErrorBoundary>
          <App />
        </ErrorBoundary>,
        document.getElementById('root')
      );
      console.log("React app rendered successfully.");
    } catch (error) {
      console.error("Failed to render React app:", error);
      document.getElementById("root").style.display = "none";
      document.getElementById("fallback").style.display = "flex";
    }
  </script>
</body>
</html>