<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LuckyU - Wallet & Lottery Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.development.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.development.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@babel/standalone@7.22.5/babel.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.7.1/dist/ethers.umd.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { ethers } = window;

    // Placeholder contract addresses (replace with actual addresses)
    const LUCK_TOKEN_ADDRESS = "0x7c1209fb8f73e37b43f25da2dd81a00565f90607";
    const LOTTERY_CONTRACT_ADDRESS = "0x58e319bb163a6952a3cff5d08f9f08112566da90";

    // Simplified ABI for the contracts (replace with actual ABIs)
    const LUCK_TOKEN_ABI = [
      "function approve(address spender, uint256 amount) public returns (bool)",
      "function allowance(address owner, address spender) public view returns (uint256)",
      "function balanceOf(address account) public view returns (uint256)",
      "function decimals() public view returns (uint8)"
    ];
    const LOTTERY_CONTRACT_ABI = [
      "function enterLottery(uint256 numberOfTickets) public",
      "function ticketPrice() public view returns (uint256)",
      "function currentLotteryId() public view returns (uint256)",
      "function getLotteryInfo(uint256 lotteryId) public view returns (uint256 startTime, uint256 endTime, uint256 resultTime, bool ended, uint256 participantCount, uint256 prizePool)"
    ];

    function App() {
      const [telegramId, setTelegramId] = React.useState("");
      const [account, setAccount] = React.useState(null);
      const [provider, setProvider] = React.useState(null);
      const [signer, setSigner] = React.useState(null);
      const [lotteryContract, setLotteryContract] = React.useState(null);
      const [luckToken, setLuckToken] = React.useState(null);
      const [lotteryInfo, setLotteryInfo] = React.useState(null);
      const [ticketPrice, setTicketPrice] = React.useState(0);
      const [ticketAmount, setTicketAmount] = React.useState(1);
      const [status, setStatus] = React.useState("");
      const [isLoading, setIsLoading] = React.useState(false);
      const [action, setAction] = React.useState("connect"); // "connect", "buy"
      const [isMobile, setIsMobile] = React.useState(false);
      const [metaMaskDetected, setMetaMaskDetected] = React.useState(false);

      // Initialize Telegram Web App and fetch lottery info
      React.useEffect(() => {
        // Telegram Web App setup
        if (window.Telegram && window.Telegram.WebApp) {
          window.Telegram.WebApp.ready();
          const user = window.Telegram.WebApp.initDataUnsafe.user;
          if (user) {
            setTelegramId(user.id.toString());
          }

          // Initialize MainButton
          window.Telegram.WebApp.MainButton.setText("Connect Wallet");
          window.Telegram.WebApp.MainButton.show();
        }

        // Detect mobile device
        const userAgent = navigator.userAgent || navigator.vendor || window.opera;
        setIsMobile(/android|iPhone|iPad|iPod/i.test(userAgent));

        // Check for MetaMask
        if (window.ethereum) {
          setMetaMaskDetected(true);
          const provider = new ethers.BrowserProvider(window.ethereum);
          setProvider(provider);

          const luckToken = new ethers.Contract(LUCK_TOKEN_ADDRESS, LUCK_TOKEN_ABI, provider);
          const lotteryContract = new ethers.Contract(LOTTERY_CONTRACT_ADDRESS, LOTTERY_CONTRACT_ABI, provider);
          setLuckToken(luckToken);
          setLotteryContract(lotteryContract);

          // Fetch lottery info
          const fetchLotteryInfo = async () => {
            try {
              const currentId = await lotteryContract.currentLotteryId();
              if (currentId > 0) {
                const [startTime, endTime, resultTime, ended, participantCount, prizePool] = await lotteryContract.getLotteryInfo(currentId);
                const ticketPrice = await lotteryContract.ticketPrice();
                setLotteryInfo({
                  id: currentId,
                  startTime: new Date(startTime * 1000).toUTCString(),
                  endTime: new Date(endTime * 1000).toUTCString(),
                  resultTime: new Date(resultTime * 1000).toUTCString(),
                  ended,
                  participantCount,
                  prizePool: ethers.formatEther(prizePool)
                });
                setTicketPrice(ethers.formatEther(ticketPrice));
              } else {
                setLotteryInfo({ id: 0 });
              }
            } catch (error) {
              setStatus(`Error fetching lottery info: ${error.message}`);
            }
          };
          fetchLotteryInfo();
        } else {
          setMetaMaskDetected(false);
          setStatus(isMobile
            ? "MetaMask not detected in Telegram's browser. Please connect using the MetaMask mobile app."
            : "MetaMask not detected. Please install MetaMask or open this app in a browser where MetaMask is installed.");
        }

        // Pre-fill ticket amount from query params (if coming from /buy_tickets)
        const params = new URLSearchParams(window.location.search);
        const tickets = params.get("tickets");
        if (tickets) {
          setTicketAmount(Math.max(1, parseInt(tickets) || 1));
          setAction("buy");
        }

        // Clean up MainButton event listeners on unmount
        return () => {
          window.Telegram.WebApp.MainButton.offClick();
        };
      }, []);

      // Update MainButton based on state
      React.useEffect(() => {
        if (!window.Telegram.WebApp.MainButton) return;

        if (isLoading) {
          window.Telegram.WebApp.MainButton.setText("Processing...");
          window.Telegram.WebApp.MainButton.disable();
          return;
        }

        window.Telegram.WebApp.MainButton.enable();
        if (!metaMaskDetected) {
          if (isMobile) {
            window.Telegram.WebApp.MainButton.setText("Connect with MetaMask");
            window.Telegram.WebApp.MainButton.onClick(connectWalletMobile);
          } else {
            window.Telegram.WebApp.MainButton.setText("Open in Browser");
            window.Telegram.WebApp.MainButton.onClick(() => {
              window.Telegram.WebApp.openLink(window.location.href);
            });
          }
        } else if (action === "connect" && !account) {
          window.Telegram.WebApp.MainButton.setText("Connect Wallet");
          window.Telegram.WebApp.MainButton.onClick(connectWallet);
        } else if (action === "buy") {
          window.Telegram.WebApp.MainButton.setText(`Buy ${ticketAmount} Ticket${ticketAmount > 1 ? 's' : ''}`);
          window.Telegram.WebApp.MainButton.onClick(buyTickets);
        } else {
          window.Telegram.WebApp.MainButton.setText("Buy Tickets");
          window.Telegram.WebApp.MainButton.onClick(() => setAction("buy"));
        }
      }, [metaMaskDetected, isMobile, account, action, ticketAmount, isLoading]);

      const connectWallet = async () => {
        setIsLoading(true);
        setStatus("");
        try {
          if (!provider) {
            setStatus("MetaMask not detected. Please install MetaMask.");
            setIsLoading(false);
            return;
          }

          const accounts = await provider.send("eth_requestAccounts", []);
          const signer = await provider.getSigner();
          setAccount(accounts[0]);
          setSigner(signer);
          setStatus("Wallet connected! Verifying ownership...");

          // Generate nonce and sign message
          const nonce = Math.floor(Math.random() * 900000000) + 100000000;
          const message = `LuckyU: Link wallet to Telegram ID ${telegramId}. Nonce: ${nonce}`;
          const signature = await signer.signMessage(message);

          // Send wallet address and signature to bot
          window.Telegram.WebApp.sendData(JSON.stringify({
            type: "wallet_verification",
            address: accounts[0],
            signature,
            message
          }));
          setStatus("Wallet verification submitted! Please wait for confirmation.");
          setAction("buy"); // Switch to buy mode after connecting
        } catch (error) {
          setStatus(`Error connecting wallet: ${error.message}`);
        } finally {
          setIsLoading(false);
        }
      };

      const connectWalletMobile = async () => {
        setIsLoading(true);
        setStatus("");
        try {
          // Generate nonce and message for signing
          const nonce = Math.floor(Math.random() * 900000000) + 100000000;
          const message = `LuckyU: Link wallet to Telegram ID ${telegramId}. Nonce: ${nonce}`;
          
          // Create a deep link to MetaMask for signing
          const encodedMessage = encodeURIComponent(message);
          const deepLink = `https://metamask.app.link/dapp/${window.location.host}${window.location.pathname}?action=sign&message=${encodedMessage}&telegramId=${telegramId}&nonce=${nonce}`;
          
          // Open MetaMask app
          window.Telegram.WebApp.openLink(deepLink);
          
          // Note: The actual signing and verification will need to be handled via a callback or redirect.
          // Since MetaMask deep linking doesn't allow direct callback to Telegram, we'll instruct the user to return.
          setStatus("Please sign the message in MetaMask and return to Telegram to continue.");
          
          // For this example, we'll assume the user will manually return to the app.
          // In a production environment, you might need a backend to handle the callback and signature verification.
        } catch (error) {
          setStatus(`Error connecting wallet on mobile: ${error.message}`);
        } finally {
          setIsLoading(false);
        }
      };

      const approveTokens = async (amount) => {
        setIsLoading(true);
        setStatus("");
        try {
          if (!signer || !luckToken) {
            setStatus("Please connect your wallet first.");
            setIsLoading(false);
            return;
          }

          const amountBigInt = ethers.parseEther(amount.toString());
          const tx = await luckToken.connect(signer).approve(LOTTERY_CONTRACT_ADDRESS, amountBigInt);
          await tx.wait();
          setStatus("Approval successful! Proceeding to buy tickets...");
        } catch (error) {
          setStatus(`Error approving tokens: ${error.message}`);
          throw error;
        } finally {
          setIsLoading(false);
        }
      };

      const buyTickets = async () => {
        setIsLoading(true);
        setStatus("");
        try {
          if (!signer || !lotteryContract || !luckToken) {
            setStatus("Please connect your wallet first.");
            setIsLoading(false);
            return;
          }

          if (!lotteryInfo || lotteryInfo.id === 0) {
            setStatus("No active lottery available.");
            setIsLoading(false);
            return;
          }

          if (lotteryInfo.ended || new Date(lotteryInfo.endTime) < new Date()) {
            setStatus("This lottery has ended. Please wait for the next one.");
            setIsLoading(false);
            return;
          }

          const totalCost = ticketPrice * ticketAmount;
          const balance = await luckToken.balanceOf(account);
          if (ethers.formatEther(balance) < totalCost) {
            setStatus(`Insufficient $LUCK balance. You need ${totalCost} $LUCK.`);
            setIsLoading(false);
            return;
          }

          const allowance = await luckToken.allowance(account, LOTTERY_CONTRACT_ADDRESS);
          if (ethers.formatEther(allowance) < totalCost) {
            setStatus(`Insufficient allowance. Approving ${totalCost} $LUCK...`);
            await approveTokens(totalCost);
          }

          const tx = await lotteryContract.connect(signer).enterLottery(ticketAmount);
          await tx.wait();
          setStatus(`Successfully bought ${ticketAmount} ticket(s)!`);

          // Send confirmation to bot
          window.Telegram.WebApp.sendData(JSON.stringify({
            type: "purchased",
            tickets: ticketAmount
          }));
        } catch (error) {
          setStatus(`Error buying tickets: ${error.message}`);
        } finally {
          setIsLoading(false);
        }
      };

      return (
        <div className="min-h-screen bg-gradient-to-b from-purple-500 to-pink-500 flex items-center justify-center p-4">
          <div className="bg-white rounded-lg shadow-xl p-6 max-w-lg w-full">
            <div className="flex items-center justify-center mb-4">
              <h1 className="text-3xl font-bold text-purple-600">LuckyU ü¶ô</h1>
            </div>

            {/* Wallet Section */}
            <div className="mb-6">
              <h2 className="text-xl font-semibold text-gray-800 mb-2">Wallet</h2>
              {account ? (
                <div className="bg-green-100 p-3 rounded-lg">
                  <p className="text-green-800 font-medium">
                    Connected: {account.slice(0, 6)}...{account.slice(-4)}
                  </p>
                </div>
              ) : (
                <p className="text-gray-600">
                  {metaMaskDetected
                    ? "Click the button below to connect your wallet."
                    : isMobile
                      ? "Click the button below to connect with the MetaMask mobile app."
                      : "MetaMask not detected. Click the button below to open in a browser where MetaMask is installed."}
                </p>
              )}
            </div>

            {/* Lottery Info Section */}
            <div className="mb-6">
              <h2 className="text-xl font-semibold text-gray-800 mb-2">Current Lottery</h2>
              {lotteryInfo && lotteryInfo.id > 0 ? (
                <div className="bg-gray-100 p-4 rounded-lg">
                  <p className="text-gray-700">Lottery ID: #{lotteryInfo.id}</p>
                  <p className="text-gray-700">Prize Pool: {lotteryInfo.prizePool} $LUCK</p>
                  <p className="text-gray-700">Participants: {lotteryInfo.participantCount}</p>
                  <p className="text-gray-700">Ends: {lotteryInfo.endTime}</p>
                  <p className="text-gray-700">Ticket Price: {ticketPrice} $LUCK</p>
                </div>
              ) : (
                <p className="text-gray-600">No active lottery yet. Stay tuned! ü¶ô</p>
              )}
            </div>

            {/* Buy Tickets Section */}
            {lotteryInfo && lotteryInfo.id > 0 && action === "buy" && (
              <div className="mb-6">
                <h2 className="text-xl font-semibold text-gray-800 mb-2">Buy Tickets üéüÔ∏è</h2>
                <div className="flex items-center space-x-4 mb-4">
                  <input
                    type="number"
                    min="1"
                    value={ticketAmount}
                    onChange={(e) => setTicketAmount(Math.max(1, parseInt(e.target.value) || 1))}
                    className="w-20 p-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500"
                  />
                  <p className="text-gray-600">
                    Total: {(ticketPrice * ticketAmount).toFixed(2)} $LUCK
                  </p>
                </div>
              </div>
            )}

            {/* Status Messages */}
            {status && (
              <div className={`p-3 rounded-lg text-sm ${
                status.includes('Error') ? 'bg-red-100 text-red-800' : 'bg-green-100 text-green-800'
              }`}>
                {status}
              </div>
            )}
          </div>
        </div>
      );
    }

    ReactDOM.render(<App />, document.getElementById('root'));
  </script>
</body>
</html>