<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LuckyU - Wallet & Lottery Dashboard</title>
  <!-- Load scripts -->
  <script src="https://unpkg.com/react@18.2.0/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18.2.0/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone@7.24.7/babel.min.js" crossorigin></script>
  <script src="https://unpkg.com/ethers@6.13.2/dist/ethers.umd.min.js" crossorigin></script>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .fallback-message {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      text-align: center;
      padding: 20px;
      background: linear-gradient(to bottom, #8b5cf6, #ec4899);
      color: white;
    }
    .fallback-message h1 {
      font-size: 24px;
      margin-bottom: 10px;
    }
    .fallback-message p {
      font-size: 16px;
      margin-bottom: 20px;
    }
    .fallback-message button {
      padding: 10px 20px;
      background-color: white;
      color: #8b5cf6;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <div id="fallback" class="fallback-message" style="display: none;">
    <h1>⚠️ Something Went Wrong</h1>
    <p>Unable to load the LuckyU app. Please try refreshing the page or check the console for errors.</p>
    <button onclick="window.location.reload()">Refresh</button>
  </div>

  <script type="text/babel">
    // Check if dependencies are loaded
    if (!window.React || !window.ReactDOM || !window.Babel || !window.ethers) {
      console.error("Failed to load one or more dependencies:", {
        React: !!window.React,
        ReactDOM: !!window.ReactDOM,
        Babel: !!window.Babel,
        ethers: !!window.ethers,
        Telegram: !!window.Telegram,
      });
      document.getElementById("root").style.display = "none";
      document.getElementById("fallback").style.display = "flex";
      throw new Error("Required dependencies not loaded.");
    }

    const { ethers } = window;

    // Contract addresses (replace with actual addresses)
    const LUCK_TOKEN_ADDRESS = "0x7c1209fb8f73e37b43f25da2dd81a00565f90607"; // Replace with your $LUCK token address
    const LOTTERY_CONTRACT_ADDRESS = "0x58E319BB163A6952A3cfF5d08F9f08112566Da90"; // Replace with your lottery contract address
    const EXPECTED_CHAIN_ID = 97; // BNB Chain testnet (use 56 for mainnet)

    // Simplified ABI for the contracts (replace with actual ABIs if needed)
    const LUCK_TOKEN_ABI = [
      "function approve(address spender, uint256 amount) public returns (bool)",
      "function allowance(address owner, address spender) public view returns (uint256)",
      "function balanceOf(address account) public view returns (uint256)",
      "function decimals() public view returns (uint8)"
    ];
    const LOTTERY_CONTRACT_ABI = [
      "function enterLottery(uint256 numberOfTickets) public",
      "function ticketPrice() public view returns (uint256)",
      "function currentLotteryId() public view returns (uint256)",
      "function getLotteryInfo(uint256 lotteryId) public view returns (uint256 startTime, uint256 endTime, uint256 resultTime, bool ended, uint256 participantCount, uint256 prizePool)"
    ];

    function App() {
      const [telegramId, setTelegramId] = React.useState("");
      const [account, setAccount] = React.useState(null);
      const [provider, setProvider] = React.useState(null);
      const [signer, setSigner] = React.useState(null);
      const [lotteryContract, setLotteryContract] = React.useState(null);
      const [luckToken, setLuckToken] = React.useState(null);
      const [lotteryInfo, setLotteryInfo] = React.useState(null);
      const [ticketPrice, setTicketPrice] = React.useState(0);
      const [ticketAmount, setTicketAmount] = React.useState(1);
      const [status, setStatus] = React.useState("");
      const [isLoading, setIsLoading] = React.useState(false);
      const [action, setAction] = React.useState("connect"); // "connect", "buy"
      const [isMobile, setIsMobile] = React.useState(false);
      const [isIOS, setIsIOS] = React.useState(false);
      const [walletProvider, setWalletProvider] = React.useState(null); // "metamask", null

      // Initialize Telegram Web App and fetch lottery info
      React.useEffect(() => {
        console.log("Initializing LuckyU app...");

        // Get query parameters
        const params = new URLSearchParams(window.location.search);
        const telegramIdFromQuery = params.get("telegramId");
        const actionFromQuery = params.get("action");
        const messageFromQuery = params.get("message");
        const nonceFromQuery = params.get("nonce");

        // Telegram Web App setup
        if (window.Telegram && window.Telegram.WebApp) {
          console.log("Telegram Web App detected.");
          window.Telegram.WebApp.ready();
          const user = window.Telegram.WebApp.initDataUnsafe.user;
          if (user) {
            setTelegramId(user.id.toString());
            console.log("Telegram user ID set from Telegram SDK:", user.id);
          } else if (telegramIdFromQuery) {
            setTelegramId(telegramIdFromQuery);
            console.log("Telegram user ID set from query parameter:", telegramIdFromQuery);
          }

          // Initialize MainButton
          window.Telegram.WebApp.MainButton.setText("Connect Wallet");
          window.Telegram.WebApp.MainButton.show();
        } else if (telegramIdFromQuery) {
          setTelegramId(telegramIdFromQuery);
          console.log("Telegram Web App SDK not available, using telegramId from query:", telegramIdFromQuery);
        } else {
          console.warn("Not running in Telegram Web App environment, and no telegramId provided.");
          setStatus("Error: Telegram ID not found. Please open this app via Telegram.");
        }

        // Detect mobile device and platform
        const userAgent = navigator.userAgent || navigator.vendor || window.opera;
        setIsMobile(/android|iPhone|iPad|iPod/i.test(userAgent));
        setIsIOS(/iPhone|iPad|iPod/i.test(userAgent));
        console.log("Is mobile device:", isMobile, "Is iOS:", isIOS);

        // Check for MetaMask
        const detectWalletProvider = async () => {
          if (window.ethereum) {
            console.log("MetaMask detected.");
            setWalletProvider("metamask");
            const provider = new ethers.BrowserProvider(window.ethereum);
            setProvider(provider);

            // Check network
            const network = await provider.getNetwork();
            const chainId = Number(network.chainId);
            console.log("Connected to chain ID:", chainId);
            if (chainId !== EXPECTED_CHAIN_ID) {
              setStatus(`Please switch MetaMask to the correct network (chain ID ${EXPECTED_CHAIN_ID}).`);
              console.error("Network mismatch. Expected chain ID:", EXPECTED_CHAIN_ID, "Got:", chainId);
              return;
            }

            const luckToken = new ethers.Contract(LUCK_TOKEN_ADDRESS, LUCK_TOKEN_ABI, provider);
            const lotteryContract = new ethers.Contract(LOTTERY_CONTRACT_ADDRESS, LOTTERY_CONTRACT_ABI, provider);
            setLuckToken(luckToken);
            setLotteryContract(lotteryContract);
          } else {
            setWalletProvider(null);
            setStatus(isMobile
              ? (isIOS
                  ? "MetaMask not detected. Please open this app in MetaMask's in-app browser (see instructions below)."
                  : "MetaMask not detected. Please ensure MetaMask is installed and try connecting below.")
              : "Please install MetaMask to connect your wallet.");
            console.log("No MetaMask detected in this environment.");
          }
        };

        // Initial detection
        detectWalletProvider();

        // Re-check for wallet provider after a short delay (in case MetaMask loads asynchronously)
        const recheckInterval = setInterval(() => {
          if (!walletProvider && window.ethereum) {
            console.log("Wallet provider detected after delay.");
            detectWalletProvider();
            clearInterval(recheckInterval);
          }
        }, 1000);

        // Automatically initiate signing if action=sign
        if (actionFromQuery === "sign" && messageFromQuery && telegramIdFromQuery && nonceFromQuery && window.ethereum) {
          console.log("Detected sign action from query parameters. Initiating signing...");
          setIsLoading(true);
          setStatus("Connecting wallet and signing message...");
          const connectAndSign = async () => {
            try {
              const provider = new ethers.BrowserProvider(window.ethereum);
              setProvider(provider);

              // Check network
              const network = await provider.getNetwork();
              const chainId = Number(network.chainId);
              if (chainId !== EXPECTED_CHAIN_ID) {
                setStatus(`Please switch MetaMask to the correct network (chain ID ${EXPECTED_CHAIN_ID}).`);
                console.error("Network mismatch during signing. Expected chain ID:", EXPECTED_CHAIN_ID, "Got:", chainId);
                return;
              }

              const accounts = await provider.send("eth_requestAccounts", []);
              const signer = await provider.getSigner();
              setAccount(accounts[0]);
              setSigner(signer);
              setWalletProvider("metamask");

              const luckToken = new ethers.Contract(LUCK_TOKEN_ADDRESS, LUCK_TOKEN_ABI, provider);
              const lotteryContract = new ethers.Contract(LOTTERY_CONTRACT_ADDRESS, LOTTERY_CONTRACT_ABI, provider);
              setLuckToken(luckToken);
              setLotteryContract(lotteryContract);

              const message = decodeURIComponent(messageFromQuery);
              const signature = await signer.signMessage(message);
              console.log("Message signed:", message, "Signature:", signature);

              // Send wallet address and signature to bot
              window.Telegram.WebApp.sendData(JSON.stringify({
                type: "wallet_verification",
                address: accounts[0],
                signature,
                message
              }));
              setStatus("Wallet verification submitted! Please return to Telegram to continue.");
              setAction("buy");
            } catch (error) {
              setStatus(`Error signing message: ${error.message}`);
              console.error("Error signing message:", error);
            } finally {
              setIsLoading(false);
            }
          };
          connectAndSign();
        }

        // Fetch lottery info if provider is set
        const fetchLotteryInfo = async () => {
          if (!lotteryContract) {
            console.warn("Lottery contract not initialized yet.");
            return;
          }
          try {
            console.log("Fetching lottery info...");
            const currentId = await lotteryContract.currentLotteryId();
            if (currentId > 0) {
              const [startTime, endTime, resultTime, ended, participantCount, prizePool] = await lotteryContract.getLotteryInfo(currentId);
              setLotteryInfo({
                id: currentId,
                startTime: new Date(startTime * 1000).toUTCString(),
                endTime: new Date(endTime * 1000).toUTCString(),
                resultTime: new Date(resultTime * 1000).toUTCString(),
                ended,
                participantCount,
                prizePool: ethers.formatEther(prizePool)
              });
              const ticketPrice = await lotteryContract.ticketPrice();
              setTicketPrice(ethers.formatEther(ticketPrice));
              console.log("Lottery info fetched:", {
                id: currentId,
                prizePool: ethers.formatEther(prizePool),
                ticketPrice: ethers.formatEther(ticketPrice)
              });
            } else {
              setLotteryInfo({ id: 0 });
              console.log("No active lottery found.");
            }
          } catch (error) {
            setStatus(`Error fetching lottery info: ${error.message}. Please ensure the contract address (${LOTTERY_CONTRACT_ADDRESS}) is correct and deployed on chain ID ${EXPECTED_CHAIN_ID}.`);
            console.error("Error fetching lottery info:", error);
          }
        };
        fetchLotteryInfo();

        // Pre-fill ticket amount from query params (if coming from /buy_tickets)
        const tickets = params.get("tickets");
        if (tickets) {
          setTicketAmount(Math.max(1, parseInt(tickets) || 1));
          setAction("buy");
          console.log("Pre-filled ticket amount:", tickets);
        }

        // Clean up on unmount
        return () => {
          clearInterval(recheckInterval);
          if (window.Telegram && window.Telegram.WebApp) {
            window.Telegram.WebApp.MainButton.offClick();
          }
        };
      }, [lotteryContract]);

      // Update MainButton based on state
      React.useEffect(() => {
        if (!window.Telegram || !window.Telegram.WebApp.MainButton) return;

        if (isLoading) {
          window.Telegram.WebApp.MainButton.setText("Processing...");
          window.Telegram.WebApp.MainButton.disable();
          return;
        }

        window.Telegram.WebApp.MainButton.enable();
        if (!walletProvider && !account) {
          window.Telegram.WebApp.MainButton.setText(isMobile ? "Connect with MetaMask (Open in Browser)" : "Connect with MetaMask");
          window.Telegram.WebApp.MainButton.onClick(isMobile ? openInExternalBrowser : connectWalletMetaMask);
        } else if (action === "connect" && !account) {
          window.Telegram.WebApp.MainButton.setText("Connect Wallet");
          window.Telegram.WebApp.MainButton.onClick(connectWalletMetaMask);
        } else if (action === "buy") {
          window.Telegram.WebApp.MainButton.setText(`Buy ${ticketAmount} Ticket${ticketAmount > 1 ? 's' : ''}`);
          window.Telegram.WebApp.MainButton.onClick(buyTickets);
        } else {
          window.Telegram.WebApp.MainButton.setText("Buy Tickets");
          window.Telegram.WebApp.MainButton.onClick(() => setAction("buy"));
        }
      }, [walletProvider, isMobile, account, action, ticketAmount, isLoading]);

      const openInExternalBrowser = () => {
        const currentUrl = window.location.href;
        window.Telegram.WebApp.openLink(currentUrl);
        setStatus(isIOS
          ? "Please copy the URL and open it in MetaMask's in-app browser to connect. Alternatively, try connecting below."
          : "Please connect MetaMask in the external browser. If MetaMask doesn't connect, try the button below.");
      };

      const connectWalletMetaMaskMobile = () => {
        setIsLoading(true);
        setStatus("");
        try {
          if (!telegramId) {
            setStatus("Error: Telegram ID not found. Please restart the process in Telegram.");
            console.error("Telegram ID is missing during mobile wallet connection.");
            setIsLoading(false);
            return;
          }

          // Generate nonce and message for signing
          const nonce = Math.floor(Math.random() * 900000000) + 100000000;
          const message = `LuckyU: Link wallet to Telegram ID ${telegramId}. Nonce: ${nonce}`;
          
          // Create a deep link to MetaMask for signing
          const encodedMessage = encodeURIComponent(message);
          const deepLink = `https://metamask.app.link/dapp/${window.location.host}${window.location.pathname}?action=sign&message=${encodedMessage}&telegramId=${telegramId}&nonce=${nonce}`;
          
          // Log the deep link for debugging
          console.log("Deep link URL:", deepLink);

          // Open MetaMask app
          window.location.href = deepLink;
          setStatus(`Opening MetaMask... If this doesn't work, please copy this URL and open it in MetaMask: ${deepLink}`);
        } catch (error) {
          setStatus(`Error opening MetaMask: ${error.message}. Please copy the deep link URL from the console and open it in MetaMask.`);
          console.error("Error opening MetaMask deep link:", error);
        } finally {
          setIsLoading(false);
        }
      };

      const connectWalletMetaMask = async () => {
        setIsLoading(true);
        setStatus("");
        try {
          if (!window.ethereum) {
            setStatus(isMobile
              ? (isIOS
                  ? "MetaMask not detected. Please open this app in MetaMask's in-app browser (see instructions below)."
                  : "MetaMask not detected. Please ensure MetaMask is installed and try again.")
              : "Please install MetaMask to connect your wallet.");
            setIsLoading(false);
            return;
          }

          const provider = new ethers.BrowserProvider(window.ethereum);
          setProvider(provider);

          const network = await provider.getNetwork();
          const chainId = Number(network.chainId);
          console.log("MetaMask connected to chain ID:", chainId);
          if (chainId !== EXPECTED_CHAIN_ID) {
            setStatus(`Please switch MetaMask to the correct network (chain ID ${EXPECTED_CHAIN_ID}).`);
            console.error("Network mismatch. Expected chain ID:", EXPECTED_CHAIN_ID, "Got:", chainId);
            setIsLoading(false);
            return;
          }

          const accounts = await provider.send("eth_requestAccounts", []);
          const signer = await provider.getSigner();
          setAccount(accounts[0]);
          setSigner(signer);
          setWalletProvider("metamask");
          setStatus("Wallet connected! Verifying ownership...");
          console.log("MetaMask connected, account:", accounts[0]);

          // Generate nonce and sign message
          const nonce = Math.floor(Math.random() * 900000000) + 100000000;
          const message = `LuckyU: Link wallet to Telegram ID ${telegramId}. Nonce: ${nonce}`;
          const signature = await signer.signMessage(message);

          // Send wallet address and signature to bot
          window.Telegram.WebApp.sendData(JSON.stringify({
            type: "wallet_verification",
            address: accounts[0],
            signature,
            message
          }));
          setStatus("Wallet verification submitted! Please wait for confirmation.");
          setAction("buy"); // Switch to buy mode after connecting
        } catch (error) {
          setStatus(`Error connecting wallet: ${error.message}`);
          console.error("Error connecting MetaMask:", error);
        } finally {
          setIsLoading(false);
        }
      };

      const approveTokens = async (amount) => {
        setIsLoading(true);
        setStatus("");
        try {
          if (!signer || !luckToken) {
            setStatus("Please connect your wallet first.");
            setIsLoading(false);
            return;
          }

          const amountBigInt = ethers.parseEther(amount.toString());
          const tx = await luckToken.connect(signer).approve(LOTTERY_CONTRACT_ADDRESS, amountBigInt);
          await tx.wait();
          setStatus("Approval successful! Proceeding to buy tickets...");
          console.log("Token approval successful.");
        } catch (error) {
          setStatus(`Error approving tokens: ${error.message}`);
          console.error("Error approving tokens:", error);
          throw error;
        } finally {
          setIsLoading(false);
        }
      };

      const buyTickets = async () => {
        setIsLoading(true);
        setStatus("");
        try {
          if (!signer || !lotteryContract || !luckToken) {
            setStatus("Please connect your wallet first.");
            setIsLoading(false);
            return;
          }

          if (!lotteryInfo || lotteryInfo.id === 0) {
            setStatus("No active lottery available.");
            setIsLoading(false);
            return;
          }

          if (lotteryInfo.ended || new Date(lotteryInfo.endTime) < new Date()) {
            setStatus("This lottery has ended. Please wait for the next one.");
            setIsLoading(false);
            return;
          }

          const totalCost = ticketPrice * ticketAmount;
          const balance = await luckToken.balanceOf(account);
          if (ethers.formatEther(balance) < totalCost) {
            setStatus(`Insufficient $LUCK balance. You need ${totalCost} $LUCK.`);
            setIsLoading(false);
            return;
          }

          const allowance = await luckToken.allowance(account, LOTTERY_CONTRACT_ADDRESS);
          if (ethers.formatEther(allowance) < totalCost) {
            setStatus(`Insufficient allowance. Approving ${totalCost} $LUCK...`);
            await approveTokens(totalCost);
          }

          const tx = await lotteryContract.connect(signer).enterLottery(ticketAmount);
          await tx.wait();
          setStatus(`Successfully bought ${ticketAmount} ticket(s)!`);
          console.log(`Bought ${ticketAmount} ticket(s) successfully.`);

          // Send confirmation to bot
          window.Telegram.WebApp.sendData(JSON.stringify({
            type: "purchased",
            tickets: ticketAmount
          }));
        } catch (error) {
          setStatus(`Error buying tickets: ${error.message}`);
          console.error("Error buying tickets:", error);
        } finally {
          setIsLoading(false);
        }
      };

      return (
        <div className="min-h-screen bg-gradient-to-b from-purple-500 to-pink-500 flex items-center justify-center p-4">
          <div className="bg-white rounded-lg shadow-xl p-6 max-w-lg w-full">
            <div className="flex items-center justify-center mb-4">
              <h1 className="text-3xl font-bold text-purple-600">LuckyU 🦙</h1>
            </div>

            {/* Wallet Section */}
            <div className="mb-6">
              <h2 className="text-xl font-semibold text-gray-800 mb-2">Wallet</h2>
              {account ? (
                <div className="bg-green-100 p-3 rounded-lg">
                  <p className="text-green-800 font-medium">
                    Connected: {account.slice(0, 6)}...{account.slice(-4)}
                  </p>
                </div>
              ) : (
                <div>
                  <p className="text-gray-600 mb-2">
                    {walletProvider === "metamask"
                      ? "Click the button below to connect your MetaMask wallet."
                      : isMobile
                        ? (isIOS
                            ? "MetaMask not detected in this browser. Please open this app in MetaMask's in-app browser."
                            : "MetaMask not detected. Please ensure MetaMask is installed and try connecting below.")
                        : "Click the button below to connect with MetaMask in your browser."}
                  </p>
                  {!account && (
                    <button
                      onClick={isMobile ? connectWalletMetaMaskMobile : connectWalletMetaMask}
                      className="bg-purple-600 text-white px-4 py-2 rounded-lg hover:bg-purple-700"
                    >
                      {isMobile ? "Try Connecting MetaMask" : "Connect MetaMask"}
                    </button>
                  )}
                  {isMobile && isIOS && !walletProvider && (
                    <div className="mt-4 p-3 bg-gray-100 rounded-lg">
                      <p className="text-gray-700 text-sm">
                        <strong>iOS Instructions:</strong> Copy the current URL ({window.location.href}), open the MetaMask app, and paste the URL into MetaMask's in-app browser to connect.
                      </p>
                    </div>
                  )}
                </div>
              )}
            </div>

            {/* Lottery Info Section */}
            <div className="mb-6">
              <h2 className="text-xl font-semibold text-gray-800 mb-2">Current Lottery</h2>
              {lotteryInfo && lotteryInfo.id > 0 ? (
                <div className="bg-gray-100 p-4 rounded-lg">
                  <p className="text-gray-700">Lottery ID: #{lotteryInfo.id}</p>
                  <p className="text-gray-700">Prize Pool: {lotteryInfo.prizePool} $LUCK</p>
                  <p className="text-gray-700">Participants: {lotteryInfo.participantCount}</p>
                  <p className="text-gray-700">Ends: {lotteryInfo.endTime}</p>
                  <p className="text-gray-700">Ticket Price: {ticketPrice} $LUCK</p>
                </div>
              ) : (
                <p className="text-gray-600">No active lottery yet. Stay tuned! 🦙</p>
              )}
            </div>

            {/* Buy Tickets Section */}
            {lotteryInfo && lotteryInfo.id > 0 && action === "buy" && (
              <div className="mb-6">
                <h2 className="text-xl font-semibold text-gray-800 mb-2">Buy Tickets 🎟️</h2>
                <div className="flex items-center space-x-4 mb-4">
                  <input
                    type="number"
                    min="1"
                    value={ticketAmount}
                    onChange={(e) => setTicketAmount(Math.max(1, parseInt(e.target.value) || 1))}
                    className="w-20 p-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500"
                  />
                  <p className="text-gray-600">
                    Total: {(ticketPrice * ticketAmount).toFixed(2)} $LUCK
                  </p>
                </div>
              </div>
            )}

            {/* Status Messages */}
            {status && (
              <div className={`p-3 rounded-lg text-sm ${
                status.includes('Error') ? 'bg-red-100 text-red-800' : 'bg-green-100 text-green-800'
              }`}>
                {status}
              </div>
            )}
          </div>
        </div>
      );
    }

    // Error boundary component to catch rendering errors
    class ErrorBoundary extends React.Component {
      state = { hasError: false };

      static getDerivedStateFromError(error) {
        return { hasError: true };
      }

      componentDidCatch(error, errorInfo) {
        console.error("Error rendering React app:", error, errorInfo);
        document.getElementById("root").style.display = "none";
        document.getElementById("fallback").style.display = "flex";
      }

      render() {
        if (this.state.hasError) {
          return null; // Fallback UI is handled by the DOM
        }
        return this.props.children;
      }
    }

    // Render the app with error boundary
    try {
      ReactDOM.render(
        <ErrorBoundary>
          <App />
        </ErrorBoundary>,
        document.getElementById('root')
      );
      console.log("React app rendered successfully.");
    } catch (error) {
      console.error("Failed to render React app:", error);
      document.getElementById("root").style.display = "none";
      document.getElementById("fallback").style.display = "flex";
    }
  </script>
</body>
</html>