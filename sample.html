<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Luckie Lottery Web App</title>
    <script src="https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/ethers@6.13.5/dist/ethers.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@babel/standalone@7.23.2/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/@metamask/sdk@0.28.2/dist/browser/iife/metamask-sdk.js"></script>
    <script src="https://unpkg.com/@walletconnect/web3-provider@1.8.0/dist/umd/index.min.js"></script>
    <style>
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        .gradient-bg {
            background: linear-gradient(135deg, #FFD700 0%, #28A745 50%, #6B46C1 100%);
        }
        .debug-console {
            max-height: 200px;
            overflow-y: auto;
            background-color: #1a202c;
            color: #e2e8f0;
            padding: 10px;
            border-radius: 8px;
            font-family: monospace;
            font-size: 12px;
        }
    </style>
</head>
<body className="gradient-bg">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect } = React;

        // Contract addresses and ABIs
        const LOTTERY_CONTRACT_ADDRESS = '0x68cd3f484B9b75d6336B942B3FEa11FBDBDfc359';
        const LUCK_TOKEN_ADDRESS = '0x375c00DFCA476F427A47d4bca3Bd4bB6F48BEFEE';
        const CASHBACK_CONTRACT_ADDRESS = '0x8F597A098AA0943e8710c283358D9aA0e465C53D';
        const TOKEN_DISTRIBUTION_CONTRACT_ADDRESS = '0xb11aeE0628cdC3058502faF91fa8FC02686Cf2cc';
        const CHAIN_ID = 97;
        const BSC_TESTNET_RPCS = [
            'https://bsc-testnet-rpc.publicnode.com',
            'https://data-seed-prebsc-1-s1.bnbchain.org:8545',
            'https://bsc-testnet.bnbchain.org'
        ];
        const WEB_APP_URL = 'https://na8guy.github.io/-LUCK';

        const LOTTERY_CONTRACT_ABI = [...]; // Same as previous
        const LUCK_TOKEN_ABI = [...];
        const CASHBACK_CONTRACT_ABI = [...];
        const TOKEN_DISTRIBUTION_CONTRACT_ABI = [...];

        // Redirect to external browser if in Telegram iframe and no wallet provider
        const redirectToExternalBrowser = (userId, action) => {
            const url = `${WEB_APP_URL}?userId=${encodeURIComponent(userId)}&action=${encodeURIComponent(action)}&external=true`;
            if (window.Telegram && window.Telegram.WebApp) {
                console.log(`Redirecting to external browser: ${url}`);
                window.Telegram.WebApp.openLink(url);
            } else {
                console.log(`Opening in current browser: ${url}`);
                window.location.href = url;
            }
        };

        // Override window.open for MetaMask URL redirection
        const originalOpen = window.open;
        window.open = (url, ...args) => {
            if (url && url.startsWith('metamask://')) {
                const redirectUrl = url.replace('metamask://', 'https://metamask.app.link/');
                if (window.Telegram && window.Telegram.WebApp) {
                    console.log(`Redirecting MetaMask URL: ${url} -> ${redirectUrl}`);
                    window.Telegram.WebApp.openLink(redirectUrl);
                    return null;
                }
                return originalOpen.apply(window, [redirectUrl, ...args]);
            }
            return originalOpen.apply(window, [url, ...args]);
        };

        function App() {
            const [action, setAction] = useState('home');
            const [userId, setUserId] = useState('');
            const [lotteryId, setLotteryId] = useState('');
            const [ticketCount, setTicketCount] = useState('');
            const [walletAddress, setWalletAddress] = useState('');
            const [error, setError] = useState('');
            const [status, setStatus] = useState('');
            const [telegramUser, setTelegramUser] = useState(null);
            const [isWalletLinked, setIsWalletLinked] = useState(false);
            const [lotteryInfo, setLotteryInfo] = useState({
                currentLotteryId: '0',
                ticketPrice: '0',
                isPaused: false,
                startTime: '0',
                endTime: '0',
                resultTime: '0',
                lotteryEnded: false,
                participants: '0',
                prizePool: '0',
                active: false
            });
            const [showBuyTicketsForm, setShowBuyTicketsForm] = useState(false);
            const [buyTicketsForm, setBuyTicketsForm] = useState({ lotteryId: '', ticketCount: '' });
            const [sdk, setSdk] = useState(null);
            const [walletConnectProvider, setWalletConnectProvider] = useState(null);
            const [debugLogs, setDebugLogs] = useState([]);
            const [showDebugConsole, setShowDebugConsole] = useState(false);

            const logToConsole = (message, type = 'info') => {
                const timestamp = new Date().toLocaleTimeString();
                const serializedMessage = typeof message === 'object'
                    ? JSON.stringify(message, (key, value) => typeof value === 'bigint' ? value.toString() : value)
                    : message;
                setDebugLogs(prev => [...prev, { timestamp, message: serializedMessage, type }]);
                console.log(`[${timestamp}] ${type.toUpperCase()}: ${serializedMessage}`);
            };

            // Initialize wallet providers
            useEffect(() => {
                const initializeWallet = async () => {
                    try {
                        let provider = null;
                        let sdkInstance = null;

                        // Try MetaMask SDK
                        try {
                            logToConsole('Attempting to initialize MetaMask SDK...');
                            sdkInstance = new MetaMaskSDK.MetaMaskSDK({
                                logging: { developerMode: true },
                                dappMetadata: {
                                    name: 'Luckie Lottery',
                                    url: window.location.href,
                                    iconUrl: 'https://na8guy.github.io/-LUCK/favicon.ico'
                                },
                                checkInstallationImmediately: true,
                                forceInjectProvider: true
                            });
                            logToConsole('MetaMask SDK initialized', 'success');
                            provider = sdkInstance.getProvider();
                            if (provider) {
                                logToConsole('MetaMask SDK provider detected', 'success');
                            } else {
                                logToConsole('MetaMask SDK provider not detected', 'warn');
                            }
                        } catch (sdkErr) {
                            logToConsole(`MetaMask SDK initialization failed: ${sdkErr.message}`, 'error');
                        }

                        // Try window.ethereum
                        if (!provider && window.ethereum) {
                            logToConsole('window.ethereum detected', 'success');
                            provider = window.ethereum;
                        }

                        // Try Telegram Wallet
                        if (!provider && window.Telegram && window.Telegram.WebApp && window.Telegram.WebApp.Wallet) {
                            logToConsole('Telegram Wallet detected', 'success');
                            provider = window.Telegram.WebApp.Wallet;
                        }

                        // Try WalletConnect
                        let wcProvider = null;
                        if (!provider) {
                            try {
                                logToConsole('Attempting to initialize WalletConnect...');
                                wcProvider = new WalletConnectProvider({
                                    rpc: { [CHAIN_ID]: BSC_TESTNET_RPCS[0] },
                                    chainId: CHAIN_ID,
                                    qrcode: window.innerWidth > 768 // QR code for desktop only
                                });
                                wcProvider.on('display_uri', (uri) => {
                                    logToConsole(`WalletConnect URI: ${uri}`, 'info');
                                    if (uri.startsWith('wc:')) {
                                        const metamaskUrl = `metamask://wc?uri=${encodeURIComponent(uri)}`;
                                        logToConsole(`Opening MetaMask URL: ${metamaskUrl}`, 'info');
                                        if (window.Telegram && window.Telegram.WebApp) {
                                            window.Telegram.WebApp.openLink(metamaskUrl);
                                        } else {
                                            window.open(metamaskUrl);
                                        }
                                    }
                                });
                                logToConsole('WalletConnect initialized', 'success');
                                setWalletConnectProvider(wcProvider);
                            } catch (wcErr) {
                                logToConsole(`WalletConnect initialization failed: ${wcErr.message}`, 'error');
                            }
                        }

                        // Redirect to external browser if no provider and in Telegram iframe
                        if (!provider && !wcProvider && window.Telegram && window.Telegram.WebApp && !new URLSearchParams(window.location.search).get('external')) {
                            logToConsole('No wallet provider detected in Telegram iframe, redirecting to external browser', 'warn');
                            redirectToExternalBrowser(userId, action);
                            return;
                        }

                        if (!provider && !wcProvider) {
                            logToConsole('No wallet provider detected. Please install MetaMask or use Telegram Wallet.', 'error');
                            setError('No wallet provider detected. Please install MetaMask from https://metamask.io or use Telegram Wallet.');
                            return;
                        }

                        setSdk({
                            getProvider: () => provider || (wcProvider && wcProvider.wc),
                            connect: async () => {
                                if (wcProvider) {
                                    logToConsole('Connecting via WalletConnect...');
                                    const accounts = await wcProvider.enable();
                                    return accounts;
                                }
                                if (sdkInstance) {
                                    return await sdkInstance.connect();
                                }
                                return await provider.request({ method: 'eth_requestAccounts' });
                            },
                            terminate: () => {
                                if (sdkInstance) {
                                    sdkInstance.terminate();
                                }
                                if (wcProvider) {
                                    wcProvider.disconnect();
                                }
                            }
                        });
                        logToConsole('Wallet provider initialized', 'success');
                    } catch (err) {
                        logToConsole(`Wallet initialization failed: ${err.message}`, 'error');
                        setError(`Failed to initialize wallet: ${err.message}`);
                    }
                };
                initializeWallet();
            }, [userId, action]);

            // Initialize Telegram Web App and fetch lottery info
            useEffect(() => {
                if (window.Telegram && window.Telegram.WebApp) {
                    logToConsole('Telegram Web App SDK loaded');
                    window.Telegram.WebApp.ready();
                    window.Telegram.WebApp.expand();
                    setTelegramUser(window.Telegram.WebApp.initDataUnsafe.user || {});
                } else {
                    logToConsole('Running outside Telegram Web App', 'info');
                }

                const params = new URLSearchParams(window.location.search);
                setUserId(params.get('userId') || '');
                setAction(params.get('action') || 'home');
                setLotteryId(params.get('lotteryId') || '');
                setTicketCount(params.get('ticketCount') || '');
                logToConsole(`URL Params - userId: ${params.get('userId')}, action: ${params.get('action')}`);

                const fetchLotteryInfo = async () => {
                    try {
                        logToConsole('Fetching lottery info...');
                        let provider;
                        for (const rpc of BSC_TESTNET_RPCS) {
                            try {
                                provider = new ethers.JsonRpcProvider(rpc);
                                const network = await provider.getNetwork();
                                logToConsole(`Connected to RPC ${rpc}, chain ID: ${network.chainId}`);
                                break;
                            } catch (rpcErr) {
                                logToConsole(`Failed to connect to RPC ${rpc}: ${rpcErr.message}`, 'warn');
                            }
                        }
                        if (!provider) {
                            throw new Error('All BSC Testnet RPCs failed.');
                        }

                        const lotteryContract = new ethers.Contract(LOTTERY_CONTRACT_ADDRESS, LOTTERY_CONTRACT_ABI, provider);
                        const userIdInt = params.get('userId') ? parseInt(params.get('userId')) : 0;
                        let linkedWallet = '0x0000000000000000000000000000000000000000';
                        try {
                            linkedWallet = await lotteryContract.telegramIdToWallet(userIdInt);
                        } catch (walletErr) {
                            logToConsole(`Failed to fetch telegramIdToWallet: ${walletErr.message}`, 'warn');
                        }

                        const ticketPrice = await lotteryContract.ticketPrice();
                        const isPaused = await lotteryContract.paused();
                        const currentLotteryId = await lotteryContract.currentLotteryId();
                        let lotteryDetails;
                        try {
                            lotteryDetails = await lotteryContract.getLotteryInfo(currentLotteryId);
                            logToConsole(`getLotteryInfo: ${JSON.stringify(lotteryDetails, (k, v) => typeof v === 'bigint' ? v.toString() : v)}`);
                        } catch (lotteryErr) {
                            logToConsole(`Failed to fetch getLotteryInfo: ${lotteryErr.message}`, 'error');
                            throw new Error('Failed to fetch lottery info.');
                        }

                        let startTime, endTime, resultTime, lotteryEnded, participants, prizePool;
                        if (Array.isArray(lotteryDetails) && lotteryDetails.length >= 6) {
                            [startTime, endTime, resultTime, lotteryEnded, participants, prizePool] = lotteryDetails;
                        } else {
                            throw new Error('Invalid getLotteryInfo response.');
                        }

                        const blockTimestamp = (await provider.getBlock('latest')).timestamp;
                        setLotteryInfo({
                            currentLotteryId: currentLotteryId.toString(),
                            ticketPrice: ethers.formatEther(ticketPrice),
                            isPaused,
                            startTime: startTime.toString(),
                            endTime: endTime.toString(),
                            resultTime: resultTime.toString(),
                            lotteryEnded,
                            participants: participants.toString(),
                            prizePool: ethers.formatEther(prizePool),
                            active: !lotteryEnded &&
                                    blockTimestamp >= parseInt(startTime) &&
                                    blockTimestamp < parseInt(endTime)
                        });

                        if (linkedWallet !== '0x0000000000000000000000000000000000000000') {
                            setIsWalletLinked(true);
                            setWalletAddress(linkedWallet);
                        }
                        logToConsole('Lottery info fetched successfully', 'success');
                    } catch (err) {
                        logToConsole(`Fetch lottery info failed: ${err.message}`, 'error');
                        setError(`Failed to fetch lottery info: ${err.message}`);
                    }
                };
                fetchLotteryInfo();
            }, []);

            const triggerConfetti = () => {
                confetti({
                    particleCount: 100,
                    spread: 70,
                    origin: { y: 0.6 },
                    colors: ['#FFD700', '#28A745', '#6B46C1']
                });
            };

            const connectWallet = async () => {
                if (!sdk) {
                    logToConsole('Wallet provider not initialized', 'error');
                    setError('Wallet provider not available. Please install MetaMask or use Telegram Wallet.');
                    return null;
                }
                try {
                    setError('');
                    setStatus('Connecting to wallet...');
                    logToConsole('Attempting to connect wallet');

                    const providerAvailable = sdk.getProvider();
                    if (!providerAvailable && !walletConnectProvider) {
                        logToConsole('Wallet provider not detected', 'error');
                        setError('Wallet provider not detected. Redirecting to external browser...');
                        redirectToExternalBrowser(userId, action);
                        return null;
                    }

                    const accounts = await sdk.connect();
                    if (!accounts || accounts.length === 0) {
                        throw new Error('No accounts returned by wallet.');
                    }
                    logToConsole(`Connected account: ${accounts[0]}`);

                    const provider = new ethers.BrowserProvider(sdk.getProvider() || walletConnectProvider);
                    const signer = await provider.getSigner();
                    const address = accounts[0];
                    const currentChainId = Number((await provider.getNetwork()).chainId);

                    if (currentChainId !== CHAIN_ID) {
                        logToConsole(`Switching to chain ID ${CHAIN_ID}`);
                        try {
                            await (sdk.getProvider() || walletConnectProvider).request({
                                method: 'wallet_switchEthereumChain',
                                params: [{ chainId: `0x${CHAIN_ID.toString(16)}` }],
                            });
                        } catch (switchError) {
                            if (switchError.code === 4902) {
                                await (sdk.getProvider() || walletConnectProvider).request({
                                    method: 'wallet_addEthereumChain',
                                    params: [{
                                        chainId: `0x${CHAIN_ID.toString(16)}`,
                                        chainName: 'BNB Chain Testnet',
                                        rpcUrls: ['https://bsc-testnet-rpc.publicnode.com'],
                                        nativeCurrency: { name: 'BNB', symbol: 'BNB', decimals: 18 },
                                        blockExplorerUrls: ['https://testnet.bscscan.com']
                                    }],
                                });
                            } else {
                                throw new Error('Failed to switch to BSC Testnet.');
                            }
                        }
                    }

                    setWalletAddress(address);
                    setStatus('Wallet connected! üéâ');
                    logToConsole(`Wallet connected: ${address}`, 'success');
                    triggerConfetti();
                    return { provider, signer, address };
                } catch (err) {
                    logToConsole(`Connect wallet error: ${err.message} (Code: ${err.code})`, 'error');
                    const errorMessage = err.code === 4001 ? 'Connection rejected by user' : `Failed to connect wallet: ${err.message}`;
                    setError(errorMessage);
                    setStatus('');
                    return null;
                }
            };

            const disconnectWallet = () => {
                setWalletAddress('');
                setIsWalletLinked(false);
                if (sdk) {
                    sdk.terminate();
                    setSdk(null);
                }
                if (walletConnectProvider) {
                    walletConnectProvider.disconnect();
                    setWalletConnectProvider(null);
                }
                setStatus('Wallet disconnected! üéâ');
                logToConsole('Wallet disconnected', 'success');
                triggerConfetti();
            };

            const executeAction = async (actionToExecute) => {
                try {
                    setError('');
                    setStatus('Processing transaction...');
                    logToConsole(`Executing action: ${actionToExecute}`);

                    if (!userId || isNaN(parseInt(userId))) {
                        throw new Error('Invalid Telegram User ID.');
                    }

                    const wallet = await connectWallet();
                    if (!wallet) {
                        throw new Error('Wallet connection failed.');
                    }
                    const { provider, signer, address } = wallet;

                    const lotteryContract = new ethers.Contract(LOTTERY_CONTRACT_ADDRESS, LOTTERY_CONTRACT_ABI, signer);
                    const luckTokenContract = new ethers.Contract(LUCK_TOKEN_ADDRESS, LUCK_TOKEN_ABI, signer);
                    const cashbackContract = new ethers.Contract(CASHBACK_CONTRACT_ADDRESS, CASHBACK_CONTRACT_ABI, signer);
                    const tokenDistributionContract = new ethers.Contract(TOKEN_DISTRIBUTION_CONTRACT_ADDRESS, TOKEN_DISTRIBUTION_CONTRACT_ABI, signer);

                    if (lotteryInfo.isPaused && actionToExecute !== 'claim_cashback' && actionToExecute !== 'token_distribution' && actionToExecute !== 'delink_wallet') {
                        throw new Error('Lottery contract is paused.');
                    }

                    let tx;
                    switch (actionToExecute) {
                        case 'set_wallet': {
                            const existingWallet = await lotteryContract.telegramIdToWallet(parseInt(userId));
                            if (existingWallet !== '0x0000000000000000000000000000000000000000' &&
                                existingWallet.toLowerCase() !== address.toLowerCase()) {
                                throw new Error(`Telegram ID linked to another wallet (${existingWallet}).`);
                            }
                            tx = await lotteryContract.linkWallet(parseInt(userId), { gasLimit: 200000 });
                            break;
                        }
                        case 'buy_tickets': {
                            if (!buyTicketsForm.lotteryId || !buyTicketsForm.ticketCount || parseInt(buyTicketsForm.ticketCount) <= 0) {
                                throw new Error('Invalid lottery ID or ticket count.');
                            }
                            const ticketPrice = await lotteryContract.ticketPrice();
                            const totalCost = ticketPrice * BigInt(buyTicketsForm.ticketCount);
                            const balance = await luckTokenContract.balanceOf(address);
                            if (balance < totalCost) {
                                throw new Error(`Insufficient $LUCK balance: ${ethers.formatEther(balance)} available.`);
                            }

                            setStatus('Requesting token approval...');
                            tx = await luckTokenContract.approve(LOTTERY_CONTRACT_ADDRESS, totalCost, { gasLimit: 100000 });
                            await tx.wait();
                            setStatus('Processing ticket purchase...');
                            tx = await lotteryContract.buyTickets(parseInt(buyTicketsForm.lotteryId), parseInt(buyTicketsForm.ticketCount), { gasLimit: 300000 });
                            break;
                        }
                        case 'claim_cashback': {
                            const cashbackBalance = await cashbackContract.cashbackBalances(address);
                            if (cashbackBalance === 0n) {
                                throw new Error('No cashback available.');
                            }
                            tx = await cashbackContract.claimCashback({ gasLimit: 200000 });
                            break;
                        }
                        case 'token_distribution': {
                            const lastDistributionTime = await tokenDistributionContract.lastDistributionTime(address);
                            const distributionInterval = await tokenDistributionContract.distributionInterval();
                            const currentTime = Math.floor(Date.now() / 1000);
                            if (lastDistributionTime > 0 && (currentTime - lastDistributionTime) < distributionInterval) {
                                throw new Error(`Next distribution available after ${new Date((lastDistributionTime + distributionInterval) * 1000).toUTCString()}.`);
                            }
                            tx = await tokenDistributionContract.distributeTokens({ gasLimit: 200000 });
                            break;
                        }
                        case 'delink_wallet': {
                            const existingWallet = await lotteryContract.telegramIdToWallet(parseInt(userId));
                            if (existingWallet === '0x0000000000000000000000000000000000000000') {
                                throw new Error('No wallet linked.');
                            }
                            if (existingWallet.toLowerCase() !== address.toLowerCase()) {
                                throw new Error(`Connected wallet does not match linked wallet.`);
                            }
                            tx = await lotteryContract.delinkWallet(parseInt(userId), { gasLimit: 200000 });
                            break;
                        }
                        default:
                            throw new Error('Invalid action.');
                    }

                    const receipt = await tx.wait();
                    logToConsole(`Transaction confirmed: ${receipt.hash}`, 'success');
                    setStatus(`Transaction successful! Hash: ${receipt.hash} üéâ`);
                    if (window.Telegram && window.Telegram.WebApp) {
                        window.Telegram.WebApp.showAlert('Transaction completed successfully!');
                        window.Telegram.WebApp.sendData(JSON.stringify({
                            action: actionToExecute,
                            userId: userId,
                            success: true,
                            txHash: receipt.hash
                        }));
                    }

                    if (actionToExecute === 'set_wallet') {
                        setIsWalletLinked(true);
                    } else if (actionToExecute === 'delink_wallet') {
                        disconnectWallet();
                    }
                    if (actionToExecute === 'buy_tickets') {
                        setShowBuyTicketsForm(false);
                        setBuyTicketsForm({ lotteryId: '', ticketCount: '' });
                    }
                    triggerConfetti();
                } catch (err) {
                    logToConsole(`Execute action error: ${err.message}`, 'error');
                    const errorMessage = err.code === 4001 ? 'Transaction rejected by user' : `Error: ${err.message}`;
                    setError(errorMessage);
                    setStatus('');
                    if (window.Telegram && window.Telegram.WebApp) {
                        window.Telegram.WebApp.showAlert(errorMessage);
                    }
                }
            };

            const handleBuyTicketsSubmit = (e) => {
                e.preventDefault();
                executeAction('buy_tickets');
            };

            const formatTimestamp = (timestamp) => {
                if (!timestamp || timestamp === '0') return 'N/A';
                return new Date(parseInt(timestamp) * 1000).toLocaleString('en-US', {
                    dateStyle: 'medium',
                    timeStyle: 'short'
                });
            };

            const renderActionButtons = () => (
                <div className="space-y-4 animate-fade-in">
                    <button
                        onClick={() => setShowBuyTicketsForm(true)}
                        className="w-full bg-yellow-500 text-white py-3 px-4 rounded-lg hover:bg-yellow-600 transition transform hover:scale-105"
                    >
                        üéüÔ∏è Buy Tickets
                    </button>
                    <button
                        onClick={() => executeAction('claim_cashback')}
                        className="w-full bg-green-500 text-white py-3 px-4 rounded-lg hover:bg-green-600 transition transform hover:scale-105"
                    >
                        üí∏ Claim Cashback
                    </button>
                    <button
                        onClick={() => executeAction('token_distribution')}
                        className="w-full bg-purple-500 text-white py-3 px-4 rounded-lg hover:bg-purple-600 transition transform hover:scale-105"
                    >
                        üéÅ Claim Token Distribution
                    </button>
                    <button
                        onClick={() => executeAction('delink_wallet')}
                        className="w-full bg-red-500 text-white py-3 px-4 rounded-lg hover:bg-red-600 transition transform hover:scale-105"
                    >
                        üîì Delink Wallet
                    </button>
                </div>
            );

            const renderDebugConsole = () => (
                <div className="mt-4">
                    <button
                        onClick={() => setShowDebugConsole(!showDebugConsole)}
                        className="w-full bg-gray-500 text-white py-2 px-4 rounded-lg hover:bg-gray-600 transition"
                    >
                        {showDebugConsole ? 'Hide Debug Console' : 'Show Debug Console'}
                    </button>
                    {showDebugConsole && (
                        <div className="debug-console mt-2">
                            {debugLogs.map((log, index) => (
                                <div key={index} className={log.type === 'error' ? 'text-red-400' : log.type === 'warn' ? 'text-yellow-400' : 'text-gray-200'}>
                                    [{log.timestamp}] {log.message}
                                </div>
                            ))}
                        </div>
                    )}
                </div>
            );

            return (
                <div className="min-h-screen flex items-center justify-center p-4">
                    <div className="bg-white rounded-2xl shadow-xl p-8 max-w-md w-full animate-fade-in">
                        <h1 className="text-3xl font-bold text-center mb-4 text-purple-600">Luckie Lottery üé∞</h1>
                        {telegramUser && (
                            <p className="text-sm text-gray-600 mb-4 text-center">
                                Welcome, {telegramUser.first_name || 'User'}! (ID: {userId}) üéâ
                            </p>
                        )}
                        {!isWalletLinked ? (
                            <div className="text-center">
                                <h2 className="text-2xl font-semibold mb-6 text-yellow-600">Join the Lottery Fun! üéà</h2>
                                <p className="text-gray-700 mb-6">
                                    Connect your MetaMask or Telegram Wallet to start playing! üöÄ
                                </p>
                                <button
                                    onClick={() => executeAction('set_wallet')}
                                    className="w-full bg-blue-500 text-white py-3 px-4 rounded-lg hover:bg-blue-600 transition transform hover:scale-105 animate-pulse"
                                >
                                    üîó Connect Wallet
                                </button>
                                {status && <p className="mt-4 text-sm text-green-600">{status}</p>}
                                {error && <p className="mt-4 text-sm text-red-600">{error}</p>}
                            </div>
                        ) : (
                            <div>
                                <h2 className="text-2xl font-semibold mb-4 text-green-600">Ready to Win Big? üí∞</h2>
                                <p className="text-sm text-gray-600 mb-4">
                                    Connected Wallet: {walletAddress.slice(0, 6)}...{walletAddress.slice(-4)} ‚úÖ
                                </p>
                                <div className="bg-yellow-100 p-4 rounded-lg mb-6">
                                    <h3 className="text-lg font-bold text-yellow-700">Lottery Info üéüÔ∏è</h3>
                                    <p><strong>Lottery ID:</strong> {lotteryInfo.currentLotteryId}</p>
                                    <p><strong>Ticket Price:</strong> {lotteryInfo.ticketPrice} $LUCK</p>
                                    <p><strong>Start Time:</strong> {formatTimestamp(lotteryInfo.startTime)}</p>
                                    <p><strong>End Time:</strong> {formatTimestamp(lotteryInfo.endTime)}</p>
                                    <p><strong>Result Time:</strong> {formatTimestamp(lotteryInfo.resultTime)}</p>
                                    <p><strong>Prize Pool:</strong> {lotteryInfo.prizePool} $LUCK</p>
                                    <p><strong>Participants:</strong> {lotteryInfo.participants}</p>
                                    <p><strong>Status:</strong> {lotteryInfo.active ? 'Active üü¢' : 'Inactive üî¥'}</p>
                                    {lotteryInfo.isPaused && (
                                        <p className="text-red-600">‚ö†Ô∏è Lottery contract is paused.</p>
                                    )}
                                </div>
                                {showBuyTicketsForm ? (
                                    <form onSubmit={handleBuyTicketsSubmit} className="space-y-4">
                                        <div>
                                            <label className="block text-sm font-medium text-gray-700">Lottery ID</label>
                                            <input
                                                type="number"
                                                value={buyTicketsForm.lotteryId}
                                                onChange={(e) => setBuyTicketsForm({ ...buyTicketsForm, lotteryId: e.target.value })}
                                                className="w-full p-2 border rounded-lg"
                                                placeholder="Enter Lottery ID"
                                                required
                                            />
                                        </div>
                                        <div>
                                            <label className="block text-sm font-medium text-gray-700">Number of Tickets</label>
                                            <input
                                                type="number"
                                                value={buyTicketsForm.ticketCount}
                                                onChange={(e) => setBuyTicketsForm({ ...buyTicketsForm, ticketCount: e.target.value })}
                                                className="w-full p-2 border rounded-lg"
                                                placeholder="Enter ticket count"
                                                min="1"
                                                required
                                            />
                                        </div>
                                        <button
                                            type="submit"
                                            className="w-full bg-yellow-500 text-white py-3 px-4 rounded-lg hover:bg-yellow-600 transition"
                                        >
                                            Confirm Purchase üéüÔ∏è
                                        </button>
                                        <button
                                            onClick={() => setShowBuyTicketsForm(false)}
                                            className="w-full bg-gray-300 text-gray-700 py-3 px-4 rounded-lg hover:bg-gray-400 transition"
                                        >
                                            Cancel
                                        </button>
                                    </form>
                                ) : (
                                    renderActionButtons()
                                )}
                                {status && <p className="mt-4 text-sm text-green-600">{status}</p>}
                                {error && <p className="mt-4 text-sm text-red-600">{error}</p>}
                            </div>
                        )}
                        {renderDebugConsole()}
                        <div className="mt-6 text-sm text-gray-500 text-center">
                            <p>Need testnet BNB? Get it here:</p>
                            <a
                                href="https://www.bnbchain.org/en/testnet-faucet"
                                target="_blank"
                                className="text-blue-500 hover:underline"
                            >
                                BNB Testnet Faucet
                            </a>
                        </div>
                    </div>
                </div>
            );
        }

        tailwind.config = {
            theme: {
                extend: {
                    animation: {
                        'fade-in': 'fadeIn 0.5s ease-in-out',
                        'pulse': 'pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite'
                    },
                    keyframes: {
                        fadeIn: {
                            '0%': { opacity: '0', transform: 'translateY(10px)' },
                            '100%': { opacity: '1', transform: 'translateY(0)' }
                        }
                    }
                }
            }
        };

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>